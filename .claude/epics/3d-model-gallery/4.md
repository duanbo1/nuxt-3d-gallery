---
name: Core Composables & Data Access
status: open
created: 2025-10-23T05:35:03Z
updated: 2025-10-23T07:00:04Z
github: https://github.com/duanbo1/nuxt-3d-gallery/issues/4
depends_on: [3]
parallel: true
conflicts_with: []
---

# Task: Core Composables & Data Access

## Description
Create reusable Vue composables for data fetching and management. Implement `useModels()` and `useCategories()` composables that provide reactive access to the JSON data files with caching, filtering, and computed properties. These composables will be the foundation for all data access throughout the application.

## Acceptance Criteria
- [ ] `useModels()` composable implemented with filtering capabilities
- [ ] `useCategories()` composable implemented
- [ ] Data caching strategy implemented (avoid redundant fetches)
- [ ] Filtering by category, tags, and search query supported
- [ ] Sorting options (date, name, downloads) implemented
- [ ] TypeScript types properly inferred from Zod schemas
- [ ] Error handling for data fetching failures
- [ ] Unit tests for composables using Vitest

## Technical Details

### Implementation Approach

1. **Create useModels Composable** (`/composables/useModels.ts`):
   ```typescript
   import type { Model, ModelsCollection } from '~/schemas/model.schema'

   interface UseModelsOptions {
     category?: string
     tags?: string[]
     limit?: number
     sortBy?: 'date' | 'name' | 'downloads'
     sortOrder?: 'asc' | 'desc'
   }

   export const useModels = (options: UseModelsOptions = {}) => {
     // State
     const models = useState<Model[]>('models', () => [])
     const loading = useState('models-loading', () => false)
     const error = useState<Error | null>('models-error', () => null)

     // Fetch data (with caching)
     const fetchModels = async () => {
       if (models.value.length > 0) {
         return // Already cached
       }

       loading.value = true
       error.value = null

       try {
         // Import JSON directly (works at build time for SSG)
         const data: ModelsCollection = await import('~/data/models.json').then(m => m.default)
         models.value = data.models
       } catch (e) {
         error.value = e as Error
         console.error('Failed to load models:', e)
       } finally {
         loading.value = false
       }
     }

     // Computed filtered models
     const filteredModels = computed(() => {
       let result = [...models.value]

       // Filter by category
       if (options.category) {
         result = result.filter(m => m.category === options.category)
       }

       // Filter by tags
       if (options.tags && options.tags.length > 0) {
         result = result.filter(m =>
           options.tags!.some(tag => m.tags.includes(tag))
         )
       }

       // Sort
       const sortBy = options.sortBy || 'date'
       const sortOrder = options.sortOrder || 'desc'

       result.sort((a, b) => {
         let comparison = 0
         switch (sortBy) {
           case 'date':
             comparison = new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
             break
           case 'name':
             comparison = a.name.localeCompare(b.name)
             break
           case 'downloads':
             comparison = a.downloads - b.downloads
             break
         }
         return sortOrder === 'asc' ? comparison : -comparison
       })

       // Limit
       if (options.limit) {
         result = result.slice(0, options.limit)
       }

       return result
     })

     // Get single model by slug
     const getModelBySlug = (slug: string): Model | undefined => {
       return models.value.find(m => m.slug === slug)
     }

     // Get related models (same category, exclude current)
     const getRelatedModels = (currentSlug: string, limit = 4): Model[] => {
       const currentModel = getModelBySlug(currentSlug)
       if (!currentModel) return []

       return models.value
         .filter(m => m.category === currentModel.category && m.slug !== currentSlug)
         .slice(0, limit)
     }

     // Initialize on mount
     onMounted(() => {
       fetchModels()
     })

     return {
       models: filteredModels,
       allModels: models,
       loading,
       error,
       fetchModels,
       getModelBySlug,
       getRelatedModels
     }
   }
   ```

2. **Create useCategories Composable** (`/composables/useCategories.ts`):
   ```typescript
   import type { Category, CategoriesCollection } from '~/schemas/model.schema'

   export const useCategories = () => {
     // State
     const categories = useState<Category[]>('categories', () => [])
     const loading = useState('categories-loading', () => false)
     const error = useState<Error | null>('categories-error', () => null)

     // Fetch data
     const fetchCategories = async () => {
       if (categories.value.length > 0) {
         return // Already cached
       }

       loading.value = true
       error.value = null

       try {
         const data: CategoriesCollection = await import('~/data/categories.json')
           .then(m => m.default)
         categories.value = data.categories
       } catch (e) {
         error.value = e as Error
         console.error('Failed to load categories:', e)
       } finally {
         loading.value = false
       }
     }

     // Get category by slug
     const getCategoryBySlug = (slug: string): Category | undefined => {
       return categories.value.find(c => c.slug === slug)
     }

     // Get category name by ID
     const getCategoryName = (id: string): string => {
       return categories.value.find(c => c.id === id)?.name || 'Unknown'
     }

     // Initialize on mount
     onMounted(() => {
       fetchCategories()
     })

     return {
       categories,
       loading,
       error,
       fetchCategories,
       getCategoryBySlug,
       getCategoryName
     }
   }
   ```

3. **Create Unit Tests** (`/composables/__tests__/useModels.spec.ts`):
   ```typescript
   import { describe, it, expect, vi } from 'vitest'
   import { useModels } from '../useModels'

   describe('useModels', () => {
     it('should fetch and return models', async () => {
       const { models, fetchModels, loading } = useModels()

       expect(loading.value).toBe(false)
       await fetchModels()
       expect(models.value.length).toBeGreaterThan(0)
     })

     it('should filter models by category', async () => {
       const { models, fetchModels } = useModels({ category: 'nature' })
       await fetchModels()

       expect(models.value.every(m => m.category === 'nature')).toBe(true)
     })

     it('should get model by slug', async () => {
       const { getModelBySlug, fetchModels } = useModels()
       await fetchModels()

       const model = getModelBySlug('low-poly-tree')
       expect(model).toBeDefined()
       expect(model?.slug).toBe('low-poly-tree')
     })
   })
   ```

### Key Considerations
- **Caching Strategy**: Use Vue's `useState` for global state caching
- **SSR/SSG Compatibility**: Import JSON directly for build-time access
- **Reactivity**: All data should be reactive for Vue components
- **Type Safety**: Proper TypeScript types from Zod schemas
- **Performance**: Filter and sort in computed properties for efficiency

### Code Locations/Files Affected
- New files:
  - `/composables/useModels.ts`
  - `/composables/useCategories.ts`
  - `/composables/__tests__/useModels.spec.ts`
  - `/composables/__tests__/useCategories.spec.ts`

## Dependencies
- [ ] Task 3 completed (data schemas and JSON files)
- [ ] Vitest configured for unit testing

## Effort Estimate
- **Size**: S (Small)
- **Hours**: 6 hours
- **Parallel**: true (can work alongside API routes task)
- **Complexity**: Low-Medium

### Time Breakdown
- useModels implementation: 2 hours
- useCategories implementation: 1 hour
- Unit tests: 2 hours
- Testing and refinement: 1 hour

## Definition of Done
- [ ] Code implemented: Both composables complete
- [ ] Tests written and passing: Unit tests cover main scenarios
- [ ] Documentation updated: JSDoc comments on public methods
- [ ] Code reviewed: Type safety and logic verified
- [ ] Ready for use: Can be imported in components
- [ ] Verified: Works in SSR and client-side
- [ ] Verified: Caching prevents redundant data loads
- [ ] Verified: All filter/sort options work correctly
