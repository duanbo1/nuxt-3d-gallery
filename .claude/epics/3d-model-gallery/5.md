---
name: Nitro API Routes
status: open
created: 2025-10-23T05:35:03Z
updated: 2025-10-23T07:00:05Z
github: https://github.com/duanbo1/nuxt-3d-gallery/issues/5
depends_on: [3]
parallel: true
conflicts_with: []
---

# Task: Nitro API Routes

## Description
Implement Nitro API routes for server-side operations including model listing with filters, download tracking with analytics, and file locking for concurrent write operations. These endpoints handle the dynamic aspects of the application that cannot be pre-rendered.

## Acceptance Criteria
- [ ] `/api/models` GET endpoint returns filtered model list
- [ ] `/api/models/[id]/download` POST endpoint tracks downloads
- [ ] Download counter increments atomically (no race conditions)
- [ ] File locking implemented for JSON write operations
- [ ] Rate limiting added to prevent abuse
- [ ] CORS configured for API endpoints
- [ ] Error handling with proper HTTP status codes
- [ ] API endpoints return JSON responses with proper types

## Technical Details

### Implementation Approach

1. **Create Models API** (`/server/api/models/index.get.ts`):
   ```typescript
   import { ModelsCollectionSchema } from '~/schemas/model.schema'
   import type { Model } from '~/schemas/model.schema'

   export default defineEventHandler(async (event) => {
     const query = getQuery(event)

     try {
       // Read models.json
       const modelsData = await import('~/data/models.json').then(m => m.default)
       const validated = ModelsCollectionSchema.parse(modelsData)

       let models: Model[] = validated.models

       // Apply filters from query params
       if (query.category) {
         models = models.filter(m => m.category === query.category)
       }

       if (query.tag) {
         const tags = Array.isArray(query.tag) ? query.tag : [query.tag]
         models = models.filter(m =>
           tags.some(tag => m.tags.includes(tag as string))
         )
       }

       if (query.search) {
         const searchTerm = (query.search as string).toLowerCase()
         models = models.filter(m =>
           m.name.toLowerCase().includes(searchTerm) ||
           m.description.toLowerCase().includes(searchTerm) ||
           m.tags.some(tag => tag.toLowerCase().includes(searchTerm))
         )
       }

       // Sorting
       const sortBy = query.sortBy as string || 'date'
       const sortOrder = query.sortOrder as string || 'desc'

       models.sort((a, b) => {
         let comparison = 0
         switch (sortBy) {
           case 'date':
             comparison = new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
             break
           case 'name':
             comparison = a.name.localeCompare(b.name)
             break
           case 'downloads':
             comparison = a.downloads - b.downloads
             break
         }
         return sortOrder === 'asc' ? comparison : -comparison
       })

       // Pagination
       const limit = parseInt(query.limit as string) || 24
       const page = parseInt(query.page as string) || 1
       const start = (page - 1) * limit
       const end = start + limit

       const paginatedModels = models.slice(start, end)

       return {
         models: paginatedModels,
         total: models.length,
         page,
         limit,
         totalPages: Math.ceil(models.length / limit)
       }
     } catch (error) {
       throw createError({
         statusCode: 500,
         statusMessage: 'Failed to fetch models',
         data: error
       })
     }
   })
   ```

2. **Create Download Tracking API** (`/server/api/models/[id]/download.post.ts`):
   ```typescript
   import { readFileSync, writeFileSync } from 'fs'
   import { join } from 'path'
   import { ModelsCollectionSchema } from '~/schemas/model.schema'

   // Simple file lock implementation
   const locks = new Map<string, Promise<void>>()

   async function withFileLock<T>(
     filePath: string,
     fn: () => Promise<T>
   ): Promise<T> {
     // Wait for existing lock
     while (locks.has(filePath)) {
       await locks.get(filePath)
     }

     // Create new lock
     let releaseLock: () => void
     const lockPromise = new Promise<void>(resolve => {
       releaseLock = resolve
     })
     locks.set(filePath, lockPromise)

     try {
       return await fn()
     } finally {
       locks.delete(filePath)
       releaseLock!()
     }
   }

   export default defineEventHandler(async (event) => {
     const modelId = getRouterParam(event, 'id')

     if (!modelId) {
       throw createError({
         statusCode: 400,
         statusMessage: 'Model ID is required'
       })
     }

     // Rate limiting check (simple in-memory implementation)
     const ip = getRequestIP(event)
     // TODO: Implement proper rate limiting with storage

     try {
       const dataPath = join(process.cwd(), 'data/models.json')

       // Atomic update with file lock
       await withFileLock(dataPath, async () => {
         // Read current data
         const fileContent = readFileSync(dataPath, 'utf-8')
         const modelsData = JSON.parse(fileContent)
         const validated = ModelsCollectionSchema.parse(modelsData)

         // Find and update model
         const modelIndex = validated.models.findIndex(m => m.id === modelId)

         if (modelIndex === -1) {
           throw createError({
             statusCode: 404,
             statusMessage: 'Model not found'
           })
         }

         // Increment download count
         validated.models[modelIndex].downloads += 1

         // Write back atomically
         writeFileSync(dataPath, JSON.stringify(validated, null, 2), 'utf-8')
       })

       // Log analytics (could be moved to separate log file)
       console.log(`Download tracked: ${modelId} from ${ip}`)

       return {
         success: true,
         modelId,
         message: 'Download tracked successfully'
       }
     } catch (error) {
       throw createError({
         statusCode: 500,
         statusMessage: 'Failed to track download',
         data: error
       })
     }
   })
   ```

3. **Create Search API** (`/server/api/search.get.ts`):
   ```typescript
   import Fuse from 'fuse.js'
   import { ModelsCollectionSchema } from '~/schemas/model.schema'

   export default defineEventHandler(async (event) => {
     const query = getQuery(event)
     const searchQuery = query.q as string

     if (!searchQuery || searchQuery.length < 2) {
       throw createError({
         statusCode: 400,
         statusMessage: 'Search query must be at least 2 characters'
       })
     }

     try {
       const modelsData = await import('~/data/models.json').then(m => m.default)
       const validated = ModelsCollectionSchema.parse(modelsData)

       // Fuzzy search with Fuse.js
       const fuse = new Fuse(validated.models, {
         keys: ['name', 'description', 'tags', 'author'],
         threshold: 0.3,
         includeScore: true
       })

       const results = fuse.search(searchQuery)

       return {
         results: results.map(r => r.item),
         query: searchQuery,
         count: results.length
       }
     } catch (error) {
       throw createError({
         statusCode: 500,
         statusMessage: 'Search failed',
         data: error
       })
     }
   })
   ```

4. **Configure Nitro** (add to `nuxt.config.ts`):
   ```typescript
   export default defineNuxtConfig({
     // ... existing config

     nitro: {
       routeRules: {
         '/api/**': {
           cors: true,
           headers: {
             'Access-Control-Allow-Origin': '*',
             'Access-Control-Allow-Methods': 'GET, POST',
             'Access-Control-Allow-Headers': 'Content-Type'
           }
         }
       }
     }
   })
   ```

### Key Considerations
- **Atomic Operations**: File locking prevents data corruption
- **Rate Limiting**: Prevent abuse of download tracking
- **Error Handling**: Proper HTTP status codes and messages
- **Performance**: Caching strategies for frequently accessed data
- **Security**: Input validation, CORS configuration

### Code Locations/Files Affected
- New files:
  - `/server/api/models/index.get.ts`
  - `/server/api/models/[id]/download.post.ts`
  - `/server/api/search.get.ts`
- Modified files: `nuxt.config.ts`

## Dependencies
- [ ] Task 3 completed (data schemas and JSON files)
- [ ] Node.js file system access available

## Effort Estimate
- **Size**: S (Small)
- **Hours**: 8 hours
- **Parallel**: true (can work alongside composables task)
- **Complexity**: Medium (file locking requires careful implementation)

### Time Breakdown
- Models API endpoint: 2 hours
- Download tracking with locking: 3 hours
- Search API endpoint: 1 hour
- Testing and error handling: 2 hours

## Definition of Done
- [ ] Code implemented: All API routes complete
- [ ] Tests passing: Manual testing of all endpoints
- [ ] Documentation updated: API documentation in README
- [ ] Code reviewed: Error handling and security verified
- [ ] Ready for use: Can be called from frontend
- [ ] Verified: Download counter increments correctly
- [ ] Verified: No race conditions in concurrent downloads
- [ ] Verified: Rate limiting works as expected
