---
name: Search & Filter Implementation
status: open
created: 2025-10-23T05:35:03Z
updated: 2025-10-23T05:35:03Z
github: [Will be updated when synced to GitHub]
depends_on: [003, 005]
parallel: true
conflicts_with: []
---

# Task: Search & Filter Implementation

## Description
Implement comprehensive search and filtering functionality using Fuse.js for fuzzy client-side search. Create SearchBar component with debounced input, category/tag/format filters with URL parameter synchronization for shareable links, active filter chips, and optimized search performance.

## Acceptance Criteria
- [ ] `SearchBar.vue` component with debounced search (300ms)
- [ ] Fuzzy search using Fuse.js matches name, description, tags
- [ ] Category filter dropdown
- [ ] Tag multi-select filter
- [ ] Format filter (GLB, GLTF, etc.)
- [ ] URL params reflect active filters (shareable links)
- [ ] Active filter chips with remove functionality
- [ ] "Clear all filters" button
- [ ] Search results count display
- [ ] Zero-state with suggested models
- [ ] Search performance < 300ms for 500+ models

## Technical Details

### Implementation Approach

1. **Create useSearch Composable** (`/composables/useSearch.ts`):
   ```typescript
   import Fuse from 'fuse.js'
   import type { Model } from '~/schemas/model.schema'

   interface SearchFilters {
     query: string
     category: string
     tags: string[]
     format: string
   }

   export const useSearch = () => {
     const { allModels } = useModels()

     // Reactive filters
     const filters = reactive<SearchFilters>({
       query: '',
       category: '',
       tags: [],
       format: ''
     })

     // Initialize Fuse.js
     const fuse = computed(() => {
       return new Fuse(allModels.value, {
         keys: [
           { name: 'name', weight: 0.4 },
           { name: 'description', weight: 0.3 },
           { name: 'tags', weight: 0.2 },
           { name: 'author', weight: 0.1 }
         ],
         threshold: 0.3,
         includeScore: true,
         minMatchCharLength: 2
       })
     })

     // Search results
     const searchResults = computed(() => {
       let results = [...allModels.value]

       // Text search
       if (filters.query && filters.query.length >= 2) {
         const fuseResults = fuse.value.search(filters.query)
         results = fuseResults.map(r => r.item)
       }

       // Category filter
       if (filters.category) {
         results = results.filter(m => m.category === filters.category)
       }

       // Tags filter (any match)
       if (filters.tags.length > 0) {
         results = results.filter(m =>
           filters.tags.some(tag => m.tags.includes(tag))
         )
       }

       // Format filter
       if (filters.format) {
         results = results.filter(m =>
           m.formats.some(f => f.type === filters.format)
         )
       }

       return results
     })

     // Active filters count
     const activeFiltersCount = computed(() => {
       let count = 0
       if (filters.query) count++
       if (filters.category) count++
       if (filters.tags.length > 0) count += filters.tags.length
       if (filters.format) count++
       return count
     })

     // Clear all filters
     const clearFilters = () => {
       filters.query = ''
       filters.category = ''
       filters.tags = []
       filters.format = ''
     }

     // Remove specific filter
     const removeFilter = (type: keyof SearchFilters, value?: string) => {
       switch (type) {
         case 'query':
           filters.query = ''
           break
         case 'category':
           filters.category = ''
           break
         case 'format':
           filters.format = ''
           break
         case 'tags':
           if (value) {
             filters.tags = filters.tags.filter(t => t !== value)
           }
           break
       }
     }

     // Sync with URL params
     const syncWithUrl = () => {
       const route = useRoute()
       const router = useRouter()

       // Read from URL on mount
       watch(() => route.query, (query) => {
         filters.query = (query.q as string) || ''
         filters.category = (query.category as string) || ''
         filters.format = (query.format as string) || ''
         filters.tags = query.tags
           ? Array.isArray(query.tags)
             ? query.tags as string[]
             : [query.tags as string]
           : []
       }, { immediate: true })

       // Write to URL on filter change
       watch(filters, () => {
         const query: Record<string, any> = {}

         if (filters.query) query.q = filters.query
         if (filters.category) query.category = filters.category
         if (filters.format) query.format = filters.format
         if (filters.tags.length > 0) query.tags = filters.tags

         router.push({ query })
       })
     }

     return {
       filters,
       searchResults,
       activeFiltersCount,
       clearFilters,
       removeFilter,
       syncWithUrl
     }
   }
   ```

2. **Create SearchBar Component** (`/components/SearchBar.vue`):
   ```vue
   <template>
     <div class="search-bar w-full">
       <!-- Main search input -->
       <div class="relative mb-4">
         <input
           v-model="localQuery"
           type="text"
           placeholder="Search models..."
           class="w-full px-4 py-3 pl-12 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
           @input="debouncedSearch"
         />
         <IconSearch class="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />

         <!-- Clear button -->
         <button
           v-if="localQuery"
           @click="localQuery = ''; filters.query = ''"
           class="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
         >
           <IconClose class="w-5 h-5" />
         </button>
       </div>

       <!-- Filter options -->
       <div class="flex flex-wrap gap-3 mb-4">
         <!-- Category filter -->
         <select
           v-model="filters.category"
           class="px-4 py-2 border rounded-md focus:ring-2 focus:ring-blue-500"
         >
           <option value="">All Categories</option>
           <option v-for="cat in categories" :key="cat.id" :value="cat.id">
             {{ cat.name }}
           </option>
         </select>

         <!-- Format filter -->
         <select
           v-model="filters.format"
           class="px-4 py-2 border rounded-md focus:ring-2 focus:ring-blue-500"
         >
           <option value="">All Formats</option>
           <option value="GLB">GLB</option>
           <option value="GLTF">GLTF</option>
           <option value="FBX">FBX</option>
           <option value="OBJ">OBJ</option>
         </select>

         <!-- Tag selector -->
         <div class="relative">
           <button
             @click="showTagDropdown = !showTagDropdown"
             class="px-4 py-2 border rounded-md hover:bg-gray-50 flex items-center gap-2"
           >
             <span>Tags</span>
             <IconChevronDown class="w-4 h-4" />
           </button>

           <!-- Tag dropdown -->
           <div
             v-if="showTagDropdown"
             class="absolute top-full mt-1 left-0 bg-white border rounded-md shadow-lg p-2 z-10 min-w-[200px]"
           >
             <div
               v-for="tag in availableTags"
               :key="tag"
               class="flex items-center gap-2 p-2 hover:bg-gray-100 rounded cursor-pointer"
               @click="toggleTag(tag)"
             >
               <input
                 type="checkbox"
                 :checked="filters.tags.includes(tag)"
                 class="rounded"
               />
               <span class="text-sm">{{ tag }}</span>
             </div>
           </div>
         </div>

         <!-- Clear filters -->
         <button
           v-if="activeFiltersCount > 0"
           @click="clearFilters"
           class="px-4 py-2 text-red-600 hover:bg-red-50 rounded-md flex items-center gap-2"
         >
           <IconClose class="w-4 h-4" />
           Clear all ({{ activeFiltersCount }})
         </button>
       </div>

       <!-- Active filter chips -->
       <div v-if="activeFiltersCount > 0" class="flex flex-wrap gap-2 mb-4">
         <!-- Query chip -->
         <div
           v-if="filters.query"
           class="filter-chip px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm flex items-center gap-2"
         >
           <span>Search: "{{ filters.query }}"</span>
           <button @click="removeFilter('query')" class="hover:text-blue-900">
             <IconClose class="w-3 h-3" />
           </button>
         </div>

         <!-- Category chip -->
         <div
           v-if="filters.category"
           class="filter-chip px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm flex items-center gap-2"
         >
           <span>{{ getCategoryName(filters.category) }}</span>
           <button @click="removeFilter('category')" class="hover:text-green-900">
             <IconClose class="w-3 h-3" />
           </button>
         </div>

         <!-- Format chip -->
         <div
           v-if="filters.format"
           class="filter-chip px-3 py-1 bg-purple-100 text-purple-800 rounded-full text-sm flex items-center gap-2"
         >
           <span>{{ filters.format }}</span>
           <button @click="removeFilter('format')" class="hover:text-purple-900">
             <IconClose class="w-3 h-3" />
           </button>
         </div>

         <!-- Tag chips -->
         <div
           v-for="tag in filters.tags"
           :key="tag"
           class="filter-chip px-3 py-1 bg-orange-100 text-orange-800 rounded-full text-sm flex items-center gap-2"
         >
           <span>#{{ tag }}</span>
           <button @click="removeFilter('tags', tag)" class="hover:text-orange-900">
             <IconClose class="w-3 h-3" />
           </button>
         </div>
       </div>

       <!-- Results count -->
       <div class="text-sm text-gray-600 mb-4">
         {{ searchResults.length }} model{{ searchResults.length !== 1 ? 's' : '' }} found
       </div>
     </div>
   </template>

   <script setup lang="ts">
   import { useDebounceFn } from '@vueuse/core'

   const { filters, searchResults, activeFiltersCount, clearFilters, removeFilter, syncWithUrl } = useSearch()
   const { categories, getCategoryName } = useCategories()
   const { allModels } = useModels()

   // Local query for immediate UI update
   const localQuery = ref(filters.query)
   const showTagDropdown = ref(false)

   // Debounced search (300ms)
   const debouncedSearch = useDebounceFn(() => {
     filters.query = localQuery.value
   }, 300)

   // Get all available tags
   const availableTags = computed(() => {
     const tagSet = new Set<string>()
     allModels.value.forEach(model => {
       model.tags.forEach(tag => tagSet.add(tag))
     })
     return Array.from(tagSet).sort()
   })

   // Toggle tag selection
   const toggleTag = (tag: string) => {
     if (filters.tags.includes(tag)) {
       filters.tags = filters.tags.filter(t => t !== tag)
     } else {
       filters.tags.push(tag)
     }
   }

   // Click outside to close dropdown
   onClickOutside(showTagDropdown, () => {
     showTagDropdown.value = false
   })

   // Sync with URL
   onMounted(() => {
     syncWithUrl()
   })
   </script>
   ```

3. **Update Gallery Page** to use search (`/pages/index.vue`):
   ```vue
   <script setup lang="ts">
   // Replace existing filter logic with useSearch
   const { searchResults, activeFiltersCount } = useSearch()

   // Use searchResults instead of filteredModels
   const displayedModels = computed(() => {
     const start = (currentPage.value - 1) * itemsPerPage
     return searchResults.value.slice(start, start + itemsPerPage)
   })

   const totalPages = computed(() =>
     Math.ceil(searchResults.value.length / itemsPerPage)
   )
   </script>
   ```

4. **Install VueUse** (for utilities):
   ```bash
   pnpm add @vueuse/core
   ```

### Key Considerations
- **Performance**: Debouncing prevents excessive re-renders
- **UX**: Instant feedback, clear active filters
- **URL Sync**: Shareable search states
- **Accessibility**: Keyboard navigation, ARIA labels
- **Mobile**: Responsive filter controls

### Code Locations/Files Affected
- New files:
  - `/composables/useSearch.ts`
  - `/components/SearchBar.vue`
- Modified files: `/pages/index.vue`
- Package: Install `@vueuse/core`

## Dependencies
- [ ] Task 003 completed (composables)
- [ ] Task 005 completed (gallery UI)
- [ ] Fuse.js already installed from Task 001

## Effort Estimate
- **Size**: M (Medium)
- **Hours**: 12 hours
- **Parallel**: true
- **Complexity**: Medium

### Time Breakdown
- useSearch composable: 3 hours
- SearchBar component: 4 hours
- URL synchronization: 2 hours
- Filter chips and UX: 2 hours
- Testing and optimization: 1 hour

## Definition of Done
- [ ] Code implemented: Search and filters complete
- [ ] Tests passing: Search works with various queries
- [ ] Documentation updated: Search API documented
- [ ] Code reviewed: Performance verified
- [ ] Ready for use: Can search and filter models
- [ ] Verified: Search completes in < 300ms
- [ ] Verified: URL params sync correctly
- [ ] Verified: Filter chips work as expected
- [ ] Verified: Mobile-responsive design
